<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Sudoku (Neon) - 4Ã—4 / 9Ã—9 / 16Ã—16</title>
  <style>
    :root{
      --text:#F3F6FF;
      --muted:#AAB3FF;
      --accent:#00E5FF;
      --bad:#FF3D77;
      --good:#2DFF9A;

      /* JS gÃ¼nceller */
      --cell:46px;
      --gap:1px;
      --gridBorder:2px;

      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;

      /* Subgrid canlÄ± iÃ§ renkleri (1..16) */
      --bg1:  rgba(0,229,255,.10);
      --bg2:  rgba(255,61,119,.10);
      --bg3:  rgba(45,255,154,.10);
      --bg4:  rgba(255,214,0,.10);
      --bg5:  rgba(140,82,255,.10);
      --bg6:  rgba(255,138,0,.10);
      --bg7:  rgba(0,255,156,.10);
      --bg8:  rgba(255,92,247,.10);
      --bg9:  rgba(77,124,255,.10);
      --bg10: rgba(0,255,255,.10);
      --bg11: rgba(255,0,128,.10);
      --bg12: rgba(0,255,0,.10);
      --bg13: rgba(255,0,0,.10);
      --bg14: rgba(0,160,255,.10);
      --bg15: rgba(255,160,0,.10);
      --bg16: rgba(160,255,0,.10);
    }

    *{box-sizing:border-box}
    html, body{ height:100%; }
    body{
      margin:0;
      font-family:var(--font);
      color:var(--text);
      min-height:100vh;
      display:flex;
      align-items:flex-start;
      justify-content:center;
      padding:24px 14px;

      background:
        radial-gradient(900px 600px at 20% 10%, rgba(0,229,255,.25), transparent 60%),
        radial-gradient(900px 700px at 80% 20%, rgba(255,61,119,.18), transparent 60%),
        radial-gradient(1200px 800px at 50% 90%, rgba(45,255,154,.12), transparent 60%),
        linear-gradient(180deg, #050617, #070A1A);

      /* mobilde rahat dokunma + zoom davranÄ±ÅŸÄ± */
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    .wrap{
      width:min(1120px, 100%);
      display:grid;
      grid-template-columns: 1fr 360px;
      gap:16px;
    }

    .card{
      background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.015));
      border:1px solid rgba(255,255,255,.08);
      border-radius:16px;
      box-shadow: 0 12px 34px rgba(0,0,0,.32);
      overflow:hidden;
    }

    header.card{
      grid-column: 1 / -1;
      padding:14px 16px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    header .title{ display:flex; flex-direction:column; gap:4px; min-width:220px; }
    header h1{ margin:0; font-size:18px; letter-spacing:.2px; }
    header .sub{ color:var(--muted); font-size:13px; }
    .badge{
      font-size:12px;
      color:var(--muted);
      padding:6px 10px;
      border:1px solid rgba(255,255,255,.12);
      border-radius:999px;
      user-select:none;
      backdrop-filter: blur(8px);
      white-space:nowrap;
    }

    .board{ padding:14px; }

    .grid{
      display:grid;
      gap: var(--gap);
      background:rgba(255,255,255,.09);
      border: var(--gridBorder) solid rgba(255,255,255,.10);
      border-radius:12px;
      overflow:hidden;
      user-select:none;
      position:relative;
      isolation:isolate;
      width: fit-content;
      margin: 0 auto;
      touch-action: manipulation;
    }

    .cell{
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
      z-index:1;
    }

    /* Alt-kare iÃ§ renk classâ€™larÄ± */
    .sub1{  background: var(--bg1); }   .sub2{  background: var(--bg2); }
    .sub3{  background: var(--bg3); }   .sub4{  background: var(--bg4); }
    .sub5{  background: var(--bg5); }   .sub6{  background: var(--bg6); }
    .sub7{  background: var(--bg7); }   .sub8{  background: var(--bg8); }
    .sub9{  background: var(--bg9); }   .sub10{ background: var(--bg10); }
    .sub11{ background: var(--bg11); }  .sub12{ background: var(--bg12); }
    .sub13{ background: var(--bg13); }  .sub14{ background: var(--bg14); }
    .sub15{ background: var(--bg15); }  .sub16{ background: var(--bg16); }

    .cell input{
      width:100%;
      height:100%;
      border:none;
      outline:none;
      background:transparent;
      color:var(--text);
      text-align:center;
      font-size:18px;
      font-weight:700;
      caret-color:transparent;
      cursor:pointer;
      text-shadow: 0 0 10px rgba(0,229,255,.08);
      text-transform: uppercase;

      /* mobil */
      -webkit-appearance: none;
      appearance: none;
      border-radius: 0;
      touch-action: manipulation;
    }

    .cell input:focus{
      outline:2px solid rgba(0,229,255,.35);
      outline-offset:-2px;
      background:rgba(0,229,255,.08);
      box-shadow: inset 0 0 18px rgba(0,229,255,.12);
    }

    .cell.given{ background:rgba(255,255,255,.06); }
    .cell.given input{
      color:#ffffff;
      font-weight:900;
      cursor:default;
      text-shadow: 0 0 10px rgba(255,255,255,.10);
    }

    .cell.bad{ background:rgba(255,61,119,.12); }
    .cell.bad input{
      color:var(--bad);
      font-weight:900;
      text-shadow: 0 0 14px rgba(255,61,119,.22);
    }

    .cell.goodFlash{ animation: flash .25s ease-in-out 2; }
    @keyframes flash{
      0%{ background:rgba(45,255,154,.10); }
      100%{ background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01)); }
    }

    /* Alt-kare Ã§izgileri (kalÄ±n) */
    .thickRight{ box-shadow: inset -2px 0 0 0 rgba(255,255,255,.14); }
    .thickBottom{ box-shadow: inset 0 -2px 0 0 rgba(255,255,255,.14); }
    .thickRB{ box-shadow: inset -2px 0 0 0 rgba(255,255,255,.14), inset 0 -2px 0 0 rgba(255,255,255,.14); }

    /* SeÃ§ili alt-kare hÃ¼creleri ekstra parlak */
    .cell.activeSub{
      filter: brightness(1.08) saturate(1.2);
      box-shadow: inset 0 0 24px rgba(0,229,255,.18);
    }

    /* Aktif alt-kare outline overlay */
    .activeSubgrid{
      position:absolute;
      pointer-events:none;
      border-radius:10px;
      z-index:4;
      border:2px solid rgba(0,229,255,.40);
      box-shadow:
        0 0 18px rgba(0,229,255,.22),
        0 0 34px rgba(0,229,255,.12),
        0 0 0 2px rgba(0,229,255,.18) inset;
      transition: top .12s ease, left .12s ease, width .12s ease, height .12s ease;
      mix-blend-mode: screen;
      opacity:.95;
    }

    /* 9x9 iÃ§in renkli blok overlay (Ã§erÃ§eve) */
    .blockOutline{
      position:absolute;
      pointer-events:none;
      border-radius:10px;
      z-index:3;
      opacity:.95;
      transition: transform .12s ease, box-shadow .18s ease, filter .18s ease, opacity .18s ease;
      mix-blend-mode: screen;
    }
    .blockOutline::after{
      content:"";
      position:absolute;
      inset:-6px;
      border-radius:12px;
      opacity:.0;
      transition: opacity .18s ease;
    }

    .block1{ border:2px solid rgba(0,229,255,.55); box-shadow: 0 0 14px rgba(0,229,255,.18), 0 0 0 2px rgba(0,229,255,.25) inset; }
    .block2{ border:2px solid rgba(255,61,119,.55); box-shadow: 0 0 14px rgba(255,61,119,.18), 0 0 0 2px rgba(255,61,119,.25) inset; }
    .block3{ border:2px solid rgba(45,255,154,.55); box-shadow: 0 0 14px rgba(45,255,154,.18), 0 0 0 2px rgba(45,255,154,.25) inset; }
    .block4{ border:2px solid rgba(255,214,0,.55); box-shadow: 0 0 14px rgba(255,214,0,.16), 0 0 0 2px rgba(255,214,0,.22) inset; }
    .block5{ border:2px solid rgba(140,82,255,.55); box-shadow: 0 0 14px rgba(140,82,255,.18), 0 0 0 2px rgba(140,82,255,.25) inset; }
    .block6{ border:2px solid rgba(255,138,0,.55); box-shadow: 0 0 14px rgba(255,138,0,.16), 0 0 0 2px rgba(255,138,0,.22) inset; }
    .block7{ border:2px solid rgba(0,255,156,.55); box-shadow: 0 0 14px rgba(0,255,156,.18), 0 0 0 2px rgba(0,255,156,.25) inset; }
    .block8{ border:2px solid rgba(255,92,247,.55); box-shadow: 0 0 14px rgba(255,92,247,.18), 0 0 0 2px rgba(255,92,247,.25) inset; }
    .block9{ border:2px solid rgba(77,124,255,.55); box-shadow: 0 0 14px rgba(77,124,255,.18), 0 0 0 2px rgba(77,124,255,.25) inset; }

    .blockOutline.active{
      transform: scale(1.01);
      filter: saturate(1.25) brightness(1.1);
      opacity:1;
    }
    .blockOutline.active::after{
      opacity:1;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.12), transparent 55%);
      filter: blur(2px);
    }

    /* Side panel */
    .side{ padding:14px; display:flex; flex-direction:column; gap:12px; }
    .row{ display:flex; gap:10px; align-items:center; }
    label{ font-size:13px; color:var(--muted); display:block; margin-bottom:6px; }
    select{
      width:100%;
      padding:10px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.22);
      color:var(--text);
      outline:none;
      box-shadow: inset 0 0 14px rgba(0,229,255,.05);
      font-size:16px; /* mobilde daha okunaklÄ± */
    }

    button{
      width:100%;
      padding:12px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.08);
      color:var(--text);
      cursor:pointer;
      font-weight:900;
      letter-spacing:.2px;
      box-shadow: 0 10px 22px rgba(0,0,0,.25);
      transition: transform .12s ease, background .12s ease;
      touch-action: manipulation;
    }
    button:active{ transform: translateY(1px); }
    button:hover{ background:rgba(255,255,255,.12); }
    button.primary{
      background: linear-gradient(90deg, rgba(0,229,255,.35), rgba(255,61,119,.25));
      border-color: rgba(0,229,255,.45);
    }

    .stats{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .stat{
      padding:10px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.18);
      box-shadow: inset 0 0 18px rgba(0,229,255,.04);
    }
    .stat .k{ color:var(--muted); font-size:12px; }
    .stat .v{ font-size:16px; margin-top:2px; font-weight:900; }

    .msg{
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.18);
      color:var(--muted);
      min-height:44px;
      display:flex;
      align-items:center;
      box-shadow: inset 0 0 18px rgba(0,229,255,.04);
      line-height:1.35;
    }
    .msg.ok{ color:var(--good); border-color:rgba(45,255,154,.25); background:rgba(45,255,154,.08); }
    .msg.err{ color:var(--bad); border-color:rgba(255,61,119,.25); background:rgba(255,61,119,.08); }

    .numPad{ display:grid; gap:10px; margin-top:4px; }
    .numPad button{ padding:14px 0; font-size:18px; }

    .hint{ font-size:12px; color:var(--muted); line-height:1.4; }

    /* Mobil: tek kolon + keypad altta daha rahat */
    @media (max-width: 980px){
      body{ padding:16px 12px; }
      .wrap{ grid-template-columns: 1fr; gap:12px; }
      header.card{ padding:12px 14px; }
      .board{ padding:12px; }
      .side{ padding:12px; }
      .numPad button{ padding:16px 0; font-size:20px; }
    }

    /* ===== Victory overlay (tÃ¼m ekran) ===== */
    #victory{
      position:fixed;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      background: rgba(5,6,23,.55);
      backdrop-filter: blur(6px);
      z-index:9999;
      opacity:0;
      pointer-events:none;
    }

    #victory span{
      padding:30px 60px;
      font-size:56px;
      font-weight:900;
      letter-spacing:4px;
      color:#fff;
      border-radius:24px;
      background: linear-gradient(90deg, #00E5FF, #FF3D77);
      box-shadow:
        0 0 40px rgba(0,229,255,.8),
        0 0 80px rgba(255,61,119,.6);
      text-shadow:
        0 0 20px rgba(255,255,255,.9);
      transform: scale(.6) rotate(-15deg);
      white-space:nowrap;
    }

    @keyframes winIn{ 0%{opacity:0;} 100%{opacity:1;} }
    @keyframes winOut{ 0%{opacity:1;} 100%{opacity:0;} }

    @keyframes textIn{
      0%{ transform:scale(.4) rotate(-25deg); }
      60%{ transform:scale(1.15) rotate(8deg); }
      100%{ transform:scale(1) rotate(0deg); }
    }
    @keyframes textOut{
      0%{ transform:translateX(0) scale(1); }
      100%{ transform:translateX(120vw) scale(.8); }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header class="card">
      <div class="title">
        <h1>Sudoku</h1>
        <div class="sub">Neon â€¢ Boyut seÃ§imi (4Ã—4 / 9Ã—9 / 16Ã—16) â€¢ Mobil uyumlu</div>
      </div>
      <div class="badge" id="infoBadge">Boyut: 9Ã—9 â€¢ Zorluk: Orta</div>
    </header>

    <div class="card board">
      <div class="grid" id="grid" aria-label="Sudoku grid"></div>
    </div>

    <div class="card side">
      <div>
        <label for="sizeSelect">Alt-kare seÃ§imi</label>
        <select id="sizeSelect">
          <option value="2">2Ã—2 alt-kare (4Ã—4 Mini Sudoku)</option>
          <option value="3" selected>3Ã—3 alt-kare (9Ã—9 Klasik Sudoku)</option>
          <option value="4">4Ã—4 alt-kare (16Ã—16 Sudoku)</option>
        </select>
      </div>

      <div>
        <label for="difficulty">Zorluk</label>
        <select id="difficulty">
          <option value="easy">Kolay</option>
          <option value="medium" selected>Orta</option>
          <option value="hard">Zor</option>
        </select>
      </div>

      <div class="row">
        <button class="primary" id="newGame">Yeni Oyun</button>
        <button id="reset">SÄ±fÄ±rla</button>
      </div>

      <div class="row">
        <button id="check">Kontrol Et</button>
        <button id="solve">Ã‡Ã¶zÃ¼mÃ¼ GÃ¶ster</button>
      </div>

      <div class="stats">
        <div class="stat">
          <div class="k">BoÅŸ HÃ¼cre</div>
          <div class="v" id="emptyCount">0</div>
        </div>
        <div class="stat">
          <div class="k">Hata</div>
          <div class="v" id="errorCount">0</div>
        </div>
      </div>

      <div class="msg" id="message">HazÄ±r.</div>

      <div class="numPad" aria-label="number pad" id="numPad"></div>

      <div class="hint" id="hint">
        KÄ±sayollar: <b>Ok tuÅŸlarÄ±</b> gezin â€¢ <b>Backspace/Delete</b> sil â€¢ SayÄ± gir
      </div>
    </div>
  </div>

  <!-- Victory overlay (tÃ¼m ekran) -->
  <div id="victory"><span>ðŸŽ‰ TEBRÄ°KLER!</span></div>

<script>
(() => {
  // ---------- Elements ----------
  const gridEl = document.getElementById("grid");
  const victoryEl = document.getElementById("victory");
  const victoryTextEl = victoryEl.querySelector("span");

  const difficultyEl = document.getElementById("difficulty");
  const sizeEl = document.getElementById("sizeSelect");
  const badgeEl = document.getElementById("infoBadge");
  const emptyEl = document.getElementById("emptyCount");
  const errorEl = document.getElementById("errorCount");
  const msgEl = document.getElementById("message");
  const hintEl = document.getElementById("hint");

  const newBtn = document.getElementById("newGame");
  const resetBtn = document.getElementById("reset");
  const checkBtn = document.getElementById("check");
  const solveBtn = document.getElementById("solve");

  const padEl = document.getElementById("numPad");

  // ---------- State ----------
  let subSize = 3;
  let N = 9;
  let solution = null;
  let puzzle = null;
  let current = null;
  let givens = null;
  let inputs = [];
  let selected = {r:0,c:0};

  let blockOverlays = [];
  let activeBlock = 1;
  let activeSubgridOverlay = null;

  let victoryShown = false;

  // ---------- Utils ----------
  const deepCopy = (b) => b.map(r => r.slice());
  const randInt = (a,b)=>Math.floor(Math.random()*(b-a+1))+a;

  function shuffle(arr){
    for(let i=arr.length-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1));
      [arr[i],arr[j]]=[arr[j],arr[i]];
    }
    return arr;
  }

  function setCssVar(name, value){
    document.documentElement.style.setProperty(name, value);
  }

  function setMessage(text, kind=""){
    msgEl.className = "msg" + (kind ? " " + kind : "");
    msgEl.textContent = text;
  }

  function difficultyLabel(v){
    return v==="easy" ? "Kolay" : v==="medium" ? "Orta" : "Zor";
  }

  function updateBadge(){
    badgeEl.textContent = `Boyut: ${N}Ã—${N} â€¢ Zorluk: ${difficultyLabel(difficultyEl.value)}`;
  }

  function updateHint(){
    if(N === 16){
      hintEl.innerHTML = `16Ã—16: <b>1â€“16</b> gir â€¢ (Keypad en rahatÄ±) â€¢ Backspace/Delete sil`;
    } else {
      hintEl.innerHTML = `KÄ±sayollar: <b>Ok tuÅŸlarÄ±</b> gezin â€¢ <b>Backspace/Delete</b> sil â€¢ SayÄ± gir`;
    }
  }

  // ---------- Sudoku rules ----------
  function isValid(board, r, c, val){
    for(let i=0;i<N;i++){
      if(i!==c && board[r][i]===val) return false;
      if(i!==r && board[i][c]===val) return false;
    }
    const br = Math.floor(r/subSize)*subSize;
    const bc = Math.floor(c/subSize)*subSize;
    for(let i=br;i<br+subSize;i++){
      for(let j=bc;j<bc+subSize;j++){
        if((i!==r || j!==c) && board[i][j]===val) return false;
      }
    }
    return true;
  }

  function findEmpty(board){
    for(let r=0;r<N;r++){
      for(let c=0;c<N;c++){
        if(board[r][c]===0) return [r,c];
      }
    }
    return null;
  }

  function countSolutions(board, limit=2){
    const spot = findEmpty(board);
    if(!spot) return 1;
    const [r,c] = spot;

    let cnt=0;
    for(let v=1; v<=N; v++){
      board[r][c]=v;
      if(isValid(board,r,c,v)){
        cnt += countSolutions(board, limit);
        if(cnt >= limit){ board[r][c]=0; return cnt; }
      }
      board[r][c]=0;
    }
    return cnt;
  }

  // Fast solved generator
  function generateSolvedFast(){
    const base = (r,c) => (subSize*(r%subSize) + Math.floor(r/subSize) + c) % N;

    const rowGroups = shuffle(Array.from({length:subSize},(_,i)=>i));
    const colGroups = shuffle(Array.from({length:subSize},(_,i)=>i));

    const rows = [];
    for(const g of rowGroups){
      const inner = shuffle(Array.from({length:subSize},(_,i)=>i));
      for(const r of inner) rows.push(g*subSize + r);
    }

    const cols = [];
    for(const g of colGroups){
      const inner = shuffle(Array.from({length:subSize},(_,i)=>i));
      for(const c of inner) cols.push(g*subSize + c);
    }

    const nums = shuffle(Array.from({length:N},(_,i)=>i+1));

    const b = Array.from({length:N},()=>Array(N).fill(0));
    for(let r=0;r<N;r++){
      for(let c=0;c<N;c++){
        b[r][c] = nums[ base(rows[r], cols[c]) ];
      }
    }
    return b;
  }

  function makePuzzleFromSolution(sol, difficulty){
    const p = deepCopy(sol);

    let givensTarget;
    if(N===4){
      givensTarget = (difficulty==="easy") ? randInt(10,12)
                  : (difficulty==="medium") ? randInt(8,9)
                  : randInt(6,7);
    } else if(N===9){
      givensTarget = (difficulty==="easy") ? randInt(38,45)
                  : (difficulty==="medium") ? randInt(30,37)
                  : randInt(24,29);
    } else {
      givensTarget = (difficulty==="easy") ? randInt(170,190)
                  : (difficulty==="medium") ? randInt(150,169)
                  : randInt(130,149);
    }

    let cells = [];
    for(let r=0;r<N;r++) for(let c=0;c<N;c++) cells.push([r,c]);
    shuffle(cells);

    let removals = (N*N) - givensTarget;

    const doUniqueCheck = (N !== 16); // 16x16 hÄ±z iÃ§in kapalÄ±

    for(const [r,c] of cells){
      if(removals<=0) break;

      const backup = p[r][c];
      p[r][c]=0;

      if(doUniqueCheck){
        const test = deepCopy(p);
        const solCount = countSolutions(test, 2);
        if(solCount !== 1){
          p[r][c]=backup;
        } else {
          removals--;
        }
      } else {
        removals--;
      }
    }
    return p;
  }

  // ---------- Input parsing ----------
  function sanitizeValue(raw){
    let s = String(raw || "").trim();
    if(s === "") return 0;
    s = s.replace(/[^\d]/g, "");
    if(s === "") return 0;
    const v = parseInt(s,10);
    if(!Number.isFinite(v)) return 0;
    if(v < 1 || v > N) return 0;
    return v;
  }

  // ---------- Keypad ----------
  function rebuildNumPad(){
    padEl.innerHTML = "";

    let cols = 3;
    if(N===4) cols = 2;
    else if(N===9) cols = 3;
    else if(N===16) cols = 4;

    padEl.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;

    for(let v=1; v<=N; v++){
      const b = document.createElement("button");
      b.textContent = String(v);
      b.dataset.v = String(v);
      padEl.appendChild(b);
    }

    const del = document.createElement("button");
    del.textContent = "Sil";
    del.dataset.v = "0";
    del.style.gridColumn = `1 / span ${cols}`;
    padEl.appendChild(del);
  }

  // ---------- Overlays ----------
  function clearColoredBlockOverlays(){
    for(const el of blockOverlays) el.remove();
    blockOverlays = [];
  }

  function buildColoredBlockOverlaysFor9x9(){
    clearColoredBlockOverlays();
    if(N !== 9) return;

    const cellSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--cell"));
    const gap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--gap"));
    const border = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--gridBorder"));

    const blockSize = (cellSize * 3) + (gap * 2);
    const step = (cellSize * 3) + (gap * 3);

    for(let br=0;br<3;br++){
      for(let bc=0;bc<3;bc++){
        const id = br*3 + bc + 1;
        const o = document.createElement("div");
        o.className = `blockOutline block${id}`;
        o.style.top = (border + br*step) + "px";
        o.style.left = (border + bc*step) + "px";
        o.style.width = blockSize + "px";
        o.style.height = blockSize + "px";
        gridEl.appendChild(o);
        blockOverlays.push(o);
      }
    }
    setActiveBlock(activeBlock);
  }

  function setActiveBlock(blockId){
    if(N !== 9) return;
    activeBlock = blockId;
    blockOverlays.forEach((o, idx) => o.classList.toggle("active", (idx+1) === blockId));
  }

  function ensureActiveSubgridOverlay(){
    if(activeSubgridOverlay) return;
    activeSubgridOverlay = document.createElement("div");
    activeSubgridOverlay.className = "activeSubgrid";
    gridEl.appendChild(activeSubgridOverlay);
  }

  function positionActiveSubgridOverlay(r, c){
    ensureActiveSubgridOverlay();

    const cellSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--cell"));
    const gap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--gap"));
    const border = parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--gridBorder"));

    const sgR = Math.floor(r/subSize);
    const sgC = Math.floor(c/subSize);

    const size = (cellSize * subSize) + (gap * (subSize - 1));
    const step = (cellSize * subSize) + (gap * subSize);

    activeSubgridOverlay.style.top = (border + sgR * step) + "px";
    activeSubgridOverlay.style.left = (border + sgC * step) + "px";
    activeSubgridOverlay.style.width = size + "px";
    activeSubgridOverlay.style.height = size + "px";
  }

  function setActiveSubgridCells(r, c){
    const block = Math.floor(r/subSize)*subSize + Math.floor(c/subSize) + 1;
    document.querySelectorAll(".cell").forEach(e=>e.classList.remove("activeSub"));
    document.querySelectorAll(".sub" + block).forEach(e=>e.classList.add("activeSub"));
  }

  // ---------- Responsive cell sizing ----------
  function computeCellSize(){
    // grid max geniÅŸliÄŸi: mobilde ekranÄ±n Ã§oÄŸu, desktopta 520 civarÄ±
    const vw = Math.min(window.innerWidth, 640);
    const padding = (window.innerWidth <= 980) ? 24 : 40; // board iÃ§ padding hesabÄ±
    const usable = Math.max(260, vw - padding);

    // border + gaps
    const gap = 1;
    const border = 2;
    const totalGaps = gap * (N - 1);
    const totalBorder = border * 2;

    let cell = Math.floor((usable - totalGaps - totalBorder) / N);

    // clamp
    if(N === 4) cell = Math.max(52, Math.min(cell, 86));
    else if(N === 9) cell = Math.max(34, Math.min(cell, 54));
    else cell = Math.max(22, Math.min(cell, 40)); // 16x16
    return cell;
  }

  function clearCellsOnly(){
    const cells = Array.from(gridEl.querySelectorAll(".cell"));
    cells.forEach(c => c.remove());
  }

  function buildGrid(){
    setCssVar("--cell", computeCellSize() + "px");

    clearCellsOnly();
    clearColoredBlockOverlays();
    if(activeSubgridOverlay){ activeSubgridOverlay.remove(); activeSubgridOverlay=null; }
    inputs = [];

    gridEl.style.gridTemplateColumns = `repeat(${N}, var(--cell))`;
    gridEl.style.gridTemplateRows = `repeat(${N}, var(--cell))`;

    for(let r=0;r<N;r++){
      for(let c=0;c<N;c++){
        const cell = document.createElement("div");
        const block = Math.floor(r/subSize)*subSize + Math.floor(c/subSize) + 1;
        cell.className = "cell sub" + block;

        const rightThick = ((c+1) % subSize === 0) && (c !== N-1);
        const bottomThick = ((r+1) % subSize === 0) && (r !== N-1);
        if(rightThick && bottomThick) cell.classList.add("thickRB");
        else if(rightThick) cell.classList.add("thickRight");
        else if(bottomThick) cell.classList.add("thickBottom");

        const inp = document.createElement("input");
        inp.autocomplete = "off";
        inp.spellcheck = false;

        // 16x16: 1..16 -> 2 hane
        inp.maxLength = (N === 16) ? 2 : 1;
        inp.inputMode = "numeric";

        // Mobil: dokununca net focus
        inp.addEventListener("pointerdown", () => { inp.focus(); });

        inp.addEventListener("focus", () => {
          selected = {r,c};
          positionActiveSubgridOverlay(r,c);
          setActiveSubgridCells(r,c);

          if(N === 9){
            const b = Math.floor(r/3)*3 + Math.floor(c/3) + 1;
            setActiveBlock(b);
          }
        });

        inp.addEventListener("input", (e) => {
          const v = sanitizeValue(e.target.value);
          if(v === 0){
            e.target.value = "";
            applyValue(r,c,0,true);
          } else {
            e.target.value = String(v);
            applyValue(r,c,v,true);
          }
        });

        inp.addEventListener("blur", (e) => {
          const v = sanitizeValue(e.target.value);
          e.target.value = v === 0 ? "" : String(v);
          applyValue(r,c,v,false);
        });

        inp.addEventListener("keydown", (e) => {
          if(e.key === "Backspace" || e.key === "Delete"){
            e.preventDefault();
            applyValue(r,c,0,true);
            inp.value = "";
            return;
          }

          // ok tuÅŸlarÄ±
          const move = (dr,dc)=>{
            e.preventDefault();
            let nr=r+dr, nc=c+dc;
            if(nr<0) nr=0; if(nr>N-1) nr=N-1;
            if(nc<0) nc=0; if(nc>N-1) nc=N-1;
            inputs[nr*N+nc].focus();
          };
          if(e.key==="ArrowUp") return move(-1,0);
          if(e.key==="ArrowDown") return move(1,0);
          if(e.key==="ArrowLeft") return move(0,-1);
          if(e.key==="ArrowRight") return move(0,1);

          // sadece rakam
          if(e.key.length === 1 && !/[0-9]/.test(e.key)){
            e.preventDefault();
          }
        });

        cell.appendChild(inp);
        gridEl.appendChild(cell);
        inputs.push(inp);
      }
    }

    ensureActiveSubgridOverlay();
    positionActiveSubgridOverlay(0,0);
    setActiveSubgridCells(0,0);
    buildColoredBlockOverlaysFor9x9();
  }

  // ---------- Render / gameplay ----------
  function render(){
    let empties=0;
    let errors=0;

    for(let r=0;r<N;r++){
      for(let c=0;c<N;c++){
        const idx=r*N+c;
        const inp=inputs[idx];
        const cell=inp.parentElement;

        const isGiven = givens[r][c];
        cell.classList.toggle("given", isGiven);
        inp.readOnly = isGiven;

        const val = current[r][c];
        inp.value = val===0 ? "" : String(val);

        cell.classList.remove("bad");
        if(val===0){
          empties++;
        } else {
          if(!isValid(current, r, c, val)){
            cell.classList.add("bad");
            errors++;
          }
        }
      }
    }

    emptyEl.textContent = String(empties);
    errorEl.textContent = String(errors);

    if(empties===0 && errors===0){
      let ok=true;
      for(let r=0;r<N;r++) for(let c=0;c<N;c++){
        if(current[r][c]!==solution[r][c]) ok=false;
      }
      if(ok){
        setMessage("Tebrikler! Sudoku tamamlandÄ± âœ…", "ok");
        if(!victoryShown){
          victoryShown = true;
          showVictory();
        }
      }
    }
  }

  function applyValue(r,c,val, flash=false){
    if(givens[r][c]) return;
    current[r][c]=val;

    if(flash){
      const idx=r*N+c;
      const cell = inputs[idx].parentElement;
      cell.classList.remove("goodFlash");
      void cell.offsetWidth;
      cell.classList.add("goodFlash");
    }
    render();
  }

  function resetToPuzzle(){
    victoryShown = false;
    hideVictoryInstant();
    current = deepCopy(puzzle);
    setMessage("SÄ±fÄ±rlandÄ±. Devam edebilirsin.", "");
    render();
  }

  function newGame(){
    victoryShown = false;
    hideVictoryInstant();

    updateBadge();
    updateHint();

    solution = generateSolvedFast();
    puzzle = makePuzzleFromSolution(solution, difficultyEl.value);

    current = deepCopy(puzzle);
    givens = puzzle.map(row => row.map(v => v!==0));

    if(N === 16){
      setMessage("16Ã—16 hazÄ±r. SayÄ±lar: 1â€“16 (benzersiz Ã§Ã¶zÃ¼m kontrolÃ¼ hÄ±z iÃ§in kapalÄ±).", "");
    } else {
      setMessage("Yeni oyun hazÄ±r. HÃ¼cre seÃ§ ve gir.", "");
    }

    render();

    // ilk boÅŸu fokusla
    for(let i=0;i<N*N;i++){
      const r=Math.floor(i/N), c=i%N;
      if(!givens[r][c]){
        inputs[i].focus();
        break;
      }
    }
  }

  function checkBoard(){
    render();
    const errors = parseInt(errorEl.textContent,10);
    const empties = parseInt(emptyEl.textContent,10);

    if(errors===0 && empties===0){
      setMessage("Harika! Hepsi doÄŸru âœ…", "ok");
      return;
    }
    if(errors>0){
      setMessage("BazÄ± hatalar var. KÄ±rmÄ±zÄ± hÃ¼creleri dÃ¼zelt.", "err");
    } else {
      setMessage("Åžimdilik hata yok. BoÅŸ hÃ¼creleri doldur.", "");
    }
  }

  function showSolution(){
    victoryShown = false;
    hideVictoryInstant();

    current = deepCopy(solution);
    setMessage("Ã‡Ã¶zÃ¼m gÃ¶sterildi.", "");
    render();
  }

  // ---------- Victory (tÃ¼m ekran) ----------
  function hideVictoryInstant(){
    victoryEl.style.animation = "none";
    victoryTextEl.style.animation = "none";
    victoryEl.style.opacity = "0";
    victoryEl.style.pointerEvents = "none";
  }

  function showVictory(){
    victoryTextEl.textContent = "ðŸŽ‰ TEBRÄ°KLER!";
    victoryEl.style.pointerEvents = "auto";

    victoryEl.style.animation = "none";
    victoryTextEl.style.animation = "none";
    void victoryEl.offsetWidth;

    victoryEl.style.animation = "winIn .25s ease-out forwards";
    victoryTextEl.style.animation = "textIn .6s ease-out forwards";

    setTimeout(()=>{
      victoryTextEl.style.animation = "textOut 1s ease-in forwards";
      victoryEl.style.animation = "winOut 1s ease-in forwards";
    }, 2200);

    setTimeout(()=>{
      victoryEl.style.pointerEvents = "none";
    }, 3400);
  }

  // ---------- Size change ----------
  function applySizeFromSelect(){
    subSize = parseInt(sizeEl.value,10);
    N = subSize * subSize;

    activeBlock = 1;
    rebuildNumPad();
    buildGrid();
    updateBadge();
    updateHint();
    newGame();
  }

  // ---------- Events ----------
  newBtn.addEventListener("click", newGame);
  resetBtn.addEventListener("click", resetToPuzzle);
  checkBtn.addEventListener("click", checkBoard);
  solveBtn.addEventListener("click", showSolution);

  difficultyEl.addEventListener("change", () => updateBadge());
  sizeEl.addEventListener("change", () => applySizeFromSelect());

  padEl.addEventListener("click", (e) => {
    const btn = e.target.closest("button");
    if(!btn) return;

    const v = parseInt(btn.dataset.v, 10);
    const {r,c} = selected;

    const idx=r*N+c;
    const inp = inputs[idx];

    if(inp.readOnly){
      setMessage("Bu hÃ¼cre sabit (verilen). BaÅŸka hÃ¼cre seÃ§.", "err");
      return;
    }

    if(v === 0){
      inp.value = "";
      applyValue(r,c,0,true);
    } else {
      inp.value = String(v);
      applyValue(r,c,v,true);
    }
    inp.focus();
  });

  // Ekran dÃ¶ndÃ¼ / resize: cell boyutu yeniden hesapla
  function rebuildForResize(){
    setCssVar("--cell", computeCellSize() + "px");
    buildColoredBlockOverlaysFor9x9();
    positionActiveSubgridOverlay(selected.r, selected.c);
  }

  window.addEventListener("resize", () => rebuildForResize());
  window.addEventListener("orientationchange", () => setTimeout(rebuildForResize, 150));

  // ---------- Init ----------
  rebuildNumPad();
  buildGrid();
  updateBadge();
  updateHint();
  newGame();
})();
</script>
</body>
</html>
